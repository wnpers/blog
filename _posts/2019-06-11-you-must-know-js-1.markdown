---
layout: post
title:  "you must known js 1"
date:   2019-06-11 09:08:33
categories: javascript
---

### 理解js核心系列1
	
	函数声明
	函数表达式
	匿名函数
	函数作用域
	闭包
	对象构造函数
<!--more-->

#### 函数声明和函数表达式

	1、结果为一个值的任何东西都是表达式
	2、函数声明是一条语句，可以认为它包含一条隐藏的赋值语句，这条语句将函数的引用赋
	   值给一个变量。
	3、函数表达式不会自动将函数引用赋值给一个变量，你必须显式地这么做。
	4、使用函数声明定义函数，函数将在执行代码前被创建
	5、使用函数表达式定义函数，函数将在运行阶段执行代码时被创建
	6、使用函数声明时，将创建一个与函数名字相同的变量，并把对函数的引用赋值给这个
	   变量
	7、使用函数表达式时，通常不给函数制定名称，要么你手动奖它赋值给一个变量，要么以
	   其他方式使用函数表达式
	8、函数和其他值一样，可以被赋值给一个变量，可以传递给另一个函数，可以从函数中返
	   回函数，这些是他作为js一等公民的原因


#### 匿名，作用域，闭包

	1、词法作用域：通过代码接口就知道函数的作用域，变量所处在的环境
	2、闭包：函数+引用环境(自己定义的局部变量+自由变量)，包含局部变量和自由变量的
	   函数与为所有这些变量提供了变量绑定的环境一起成为闭包。
	3、通过将函数表达式用作实参来创建闭包，也就是将函数传递给函数时，也将创建闭包
	4、通过函数返回函数，生成闭包
	5、如果函数使用了自由变量，则每当你在创建该函数的上下文外面执行它时，都将创建一
	   个闭包
	6、使用时间处理程序来创建闭包



#### 对象构造函数：
构造函数 function Car(){}; 用this来指定作用域，构造函数自动返回this，不用显示的return

	var car1 = new Car(name,color,year);

	1、使用构造函数，首先要用关键字 new
	2、new关键字首先创建一个新的空对象
	3、然后，new设置this，使其指向这个新对象
	4、设置this后，调用函数Car，并将name,color,year等数据作为实参传递给它
	5、接下来，执行这个函数的代码，与大多数构造函数一样，Car给新创建的this对
	   象的属性赋值
	6、最后，Car函数执行完毕后，运算符new返回this--指向新创建的对象的引用。
	   请注意，它会自动为你返回this，你无需在代码中显示地返回。指向新对象的
	   引用被返回后，我们将其赋给变量car1

对象字面量不要被放弃，他有时候还是很有用的：
比如当构造函数需要很多实参的时候，我们向构造函数传递太多的参数，容易出错，因为

* 第一：参数很多，容易漏掉
* 第二：必须按照正确的顺序指定所有的实参
这看似只是小小的不便，但可能导致的bug比你想象的多得多；不仅如此，这些bug还常常
难以发现。
例如：

	function Car(make, model, year, color, passengers, convertible, mileage) {
		this.make = make;
		this.model = model;
		this.year = year;
		this.color = color;
		...;
		this.start = function() {
			this.started = true;
		}
	}

所以我们传递大量实参时，可以使用一种适合于任何函数的常见技巧-无论它是
常规函数还是构造函数。
这种技巧的工作原理如下：
将所有的实参都放到一个对象字面量中，再将这个对象字面量传递给函数。
这将通过一个容器（对像字面量）传递所有的值，从而不必操心参与行参的顺序问题。

那我们根据这个原理重新编写编写调用构造函数Car的代码，再稍微调整一下这个构造函数的代码。

用一个对象字面量替代所有实参

	var cadi = new Car("GM", "cadillac", 1955, "tan", 5, false, 12982);

我们调用构造函数生成car的代码可以重写成这样：

	var cadiParams = {make: "GM",
					  model: "Cadillac",
					  year: 1955,
					  color: "tan",
					  passengers: 5,
					  convertible: false,
					  mileage: 12892	
		};
	var cadi = new Car(cadiParams);

还没完，因为构造函数Car本身依然要求向他传递7个实参，而不是1个对象。下面来修改构造
函数Car代码，再进行测试。

### 理解对象实例：

### 内置构造函数：
Date,Array
数组构造函数 Array;

	var nihao = [];// 字面量表示法
	var nihao = new Array();// 构造函数表示法

是一样的

那什么时候用数组构造函数，不用字面量表示法呢
需要创建在运行阶段确定特定长度的数组，
使用构造函数很方便，

	var n = getNumbreOfWidgetsFromDatabase();//运行时才知道n的大小
	var widgets = new Array(n);
	for(var i = 0; i < n; i++) {
		widgets[i] = getDatebaseRecord(i);
	}

也就是说：要等到运行阶段才能确定长度的数组时，使用构造函数Array更合适。

其他内置对象：
用到Math 可以不用new 来创建Math对象
实际上：Math并非构造函数，甚至不是函数，而是一个对象
你知道，Math时一个内置对象，可用来获取pi的值（Math.PI）,生成随机数（Math。random）。
它首字母大写是让你知道它是内置的。



### 对象模型

在对象之间建立关系和实现共享代码，有什么方法？
还需要扩展和改进既有对象的方法。
换句话说，我们需要更多的工具。
js的对象模型很强大，它是基于原型的，可以继承和扩展其他对象的行为

我们在使用构造函数创建对象的时候，构造函数的方法可以被重用
但是这只是在代码层面实现了重用
在运行阶段，这种解决方案的效果并不好，因为每个小狗对象都将获得自己的方法副本

如果我们利用js对象模型的基于原型的概念，在这种模式中，可以通过扩展其他对象（即原型对象）
来创建对象



this

调用对象的方法时：
this被设置为方法调用的对象，即便在对象中没有找到调用的方法，而是在原型中找到了它
也不会修改this的值，在任何情况下，this都指向原始对象，即方法被调用的对象
即便方法位于原型汇总亦如此。

我们知道构造函数创建对象的的时候，new操作符先新建立一个空对象，然后将this指向这个空对象，
* 1 使用构造函数，首先要用关键字 new
* 2 new关键字首先创建一个新的空对象
* 3 然后，new设置this，使其指向这个新对象，或者说把新的空对象赋值给构造函数中的变量this
* 4 设置this后，调用函数Car，并将name,color,year等数据作为实参传递给它
* 5 接下来，执行这个函数的代码，与大多数构造函数一样，Car给新创建的this对
   象的属性赋值
* 6 最后，Car函数执行完毕后，运算符new返回this--指向新创建的对象的引用。
   请注意，它会自动为你返回this，你无需在代码中显示地返回。指向心对象的
   引用被返回后，我们将其赋给变量car1


### 原型是动态的
在原型对象中添加的任何属性和方法，都能立即被已经创建的对象继承
也就是在代码运行阶段就可以扩展和修改其所有实例的行为

我们将首先建立新对象的时候，可以通过原型方法来先利用原型属性，然后方法中代码是写给
新对象建立自己的属性，实现覆盖原型属性，下一次调用方法时，首先找到的是对象自己的那
个属性，相当于保存了对象的某个属性状态。


### 对象方法：
hasOwnProperty
通过此方法来看看对象的属性来自原型对象还是


原型属性 prototype 是一个构造函数的属性，它是一个引用，指向一个对象
原型链继承 就是通过原型


构造函数的原型对象中有两个属性："constructor" 和 "__proto__"


instanceof 的结果可以是 父级对象 也可以是爷爷级别的

我们在调用对象的consturctor属性时，由于它是 原型对象中的一个属性
我们通过原型链继承的时候，最末端的对象的这个值就会是最顶端的那个构造函数，
这里需要修复一下哦：
先将表演犬的原型指向小狗的的实例，prototype设一个新的小狗实例
ShowDog.prototype = new Dog();// 这里new了一个Dog，没有任何参数，他不像实际的小狗，
它只是一个继承小狗原型的通用小狗实例
ShowDog.prototype.constructor = ShowDog;// 修改prototype的属性值


原型链的继承代码中，表演狗的构造函数和小狗构造函数的代码有重复的
为了减少重复：
`Dog.call`

call内置方法可以对任何函数调用它；

`Dog.call(this, name, breed, weight);`

Dog是要调用的函数，

call这里导致函数Dog被调用，这不直接调用Dog，是因为这样可以控制this的值。
后面的name,breed,weight参与正常调用Dog时指定的实参相同。
这行代码调用构造函数Dog，并让其中的this指向当前的showDog实例。

这样构造函数Dog将设置当前showDog对象的属性name，breed，weight

变成下面的代码：
```
function ShowDog(name, breed, weight, handler) {
	Dog.call(this, name, breed, weight); 
	this.handler = handler;
}
```

1. 代码中的call传递了this其实就是在showDog构造函数 new 新建实例时，指向的新showDog对象
2. 而后面的参数就像通常执行构造函数Dog的代码一样，只是this指向的是showDog对象，而不是
Dog对象
3. 然后：构造函数Dog执行完毕后（我们调用它时没有使用运算符new，因此它不会返回任何对象），
4. 接着执行showDog中的其他代码，将形参handler赋值给属性this.handler


我们可以重写 Object内置属性和方法
但是下面的千万不要重写：
- constructor 指向与这个原型相关联的构造函数
- hasOwnProperty 
- isPrototypeOf 判断对象是否是另一个对象的原型
- propertyIsEnumerable 用于判断通过迭代对象的所有属性是否可访问指定的属性

可以重写：
- toString
- toLocaleString
- valueOf

### 扩展内置对象：
head first javascript 610页例子 扩展String

Array对象是不可以扩展的 注意

十大剩余主题：
- jquery
- window
- dom
- arguments
- 异常处理
- addEventListener
- 事件处理代码浏览器兼容
- 正则表达式
- 递归
- json
- 服务器端js













